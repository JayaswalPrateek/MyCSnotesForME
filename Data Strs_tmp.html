<!DOCTYPE html>
<html>
<head>
<title>Data Strs.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="mark-style%22background-ffb86ca6%22big-omark"><mark style="background: #FFB86CA6;">Big O</mark></h1>
<ul>
<li><code>O(1)</code> algorithms are most efficient as they scale really well because the execution time is independent of the input size
<ul>
<li>like searching a value in map using its key</li>
</ul>
</li>
<li><code>O(n)</code> means the execution time is linearly dependent on the input size
<ul>
<li>searching for an element in an array</li>
<li>we usually take the worst case scenario like if the element we are looking for is at the end of the array of length n then its <code>O(n)</code></li>
<li><code>O(n)</code> can be <code>O(1)</code> if the element we are looking for is at the 0th index but this is not guaranteed</li>
</ul>
</li>
<li>nested loop doesn't always imply <code>O(n^2)</code>
<ul>
<li>but <code>O(n^2)</code> can have nested loops</li>
</ul>
</li>
<li>when searching a 1-D loop twice it is <code>O(2n)</code>
<ul>
<li>so doing it n times it is <code>O(n^2)</code></li>
</ul>
</li>
<li>suppose we have a 1-D array of length n and first we traverse from 0th index to (n-1)th index
<ul>
<li>then in the 2nd pass we skip the 0th element and start from 1st element. next pass from skip the 0th, 1st element and start from 2nd element and so on</li>
<li>so we will have a total of n-1 passes for an array of length n</li>
<li>if we draw the array one below the other for every pass and erase the block we skip, we will get ◹  shape
<ul>
<li>this has base and height n-1. We ignore 1 so the square has a <code>O(n^2)</code> and ◹  shape has <code>O(n^2/2)</code> but constant doesn't matter so its still <code>O(n^2)</code></li>
</ul>
</li>
</ul>
</li>
<li>if a 2-D matrix is not a square and has sides <code>n x m</code> then it will have <code>O(n x m)</code></li>
<li><code>O(log n)</code>
<ul>
<li>we keep shrinking the array in half so we will never have to traverse all the n elements and always less than n so it will be <code>O(log n)</code></li>
<li>so n=2^x where n is the length and x is the no of times will have to split in half so take log both sides to get <code>O(log n)</code></li>
<li>used for binary trees</li>
<li>very efficient for sorted data</li>
</ul>
</li>
<li><code>O(n log n)</code> is more efficient than <code>0(n^2)</code> but less than <code>O(n)</code></li>
<li>imagine a tree which has 3 branches and each branch has 3 more branches and so on and if the height of the tree is n then <code>O(3^n)</code></li>
<li>in case of recursion if the recursive function calls itself 2 times it is <code>O(2^n)</code> as each call creates 2 more calls and each of the 2 create 2 more so it can be 2^0, 2^1 or 2^2 calls and so on
<ul>
<li>so if a recursive function is called in a loop m times then it is <code>O(m^n)</code></li>
</ul>
</li>
<li><code>O(n!)</code> is the worst</li>
<li><mark style="background: #D2B3FFA6;">efficiency decreases as gradient increases</mark>
<ul>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-21%2009-52-29.png" alt="time vs input size"></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">array/vector/string</mark>
<ul>
<li>read is <code>O(1)</code></li>
<li>insert/delete are <code>O(n)</code></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">singly linked list(forward_list)</mark>
<ul>
<li>read is <code>O(n)</code></li>
<li>insert/delete at the start is <code>O(1)</code>
<ul>
<li>at the end is <code>O(n)</code></li>
<li>anywhere else <code>O(n)</code></li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">doubly lined list(list)</mark>
<ul>
<li>read is <code>O(n)</code></li>
<li>insert/delete at the start is <code>O(1)</code>
<ul>
<li>at the end is <code>O(1)</code></li>
<li>anywhere else <code>O(n)</code></li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">dequeue</mark>
<ul>
<li>read is <code>O(n)</code></li>
<li>insert/delete front/end is <code>O(1)</code></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">priority queue</mark>
<ul>
<li>read max/min element is <code>O(1)</code></li>
<li>insert and delete is <code>O(log n)</code></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">stack</mark>
<ul>
<li>push, pop and top are <code>O(1)</code></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">queue</mark>
<ul>
<li>same as stack</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">set</mark>
<ul>
<li>read, insert and delete is <code>O(log n)</code> as it is implemented using trees</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">multiset</mark>
<ul>
<li>read and insert are <code>O(log n)</code> and delete is <code>O(k log n)</code> where k is the number of duplicate entries</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">map</mark> / <mark style="background: #D2B3FFA6;">multimap</mark>
<ul>
<li>read, insert and delete are <code>O(log n)</code></li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">unordered map</mark>
<ul>
<li>read, insert and delete are <code>O(1)</code> on average, <code>O(n)</code> in the worst case</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">pairs</mark>
<ul>
<li>read is <code>O(1)</code></li>
</ul>
</li>
</ul>
<h1 id="mark-style%22background-ffb86ca6%22stl-adtmark"><mark style="background: #FFB86CA6;">STL ADT</mark></h1>
<ul>
<li>
<p>c++ STL is a collection of useful algorithms, data structures and functions related to them in form of template classes</p>
</li>
<li>
<p>c++ STL  has 4 things: containers, functions, algorithms and iterators</p>
<ul>
<li>containers are the classes for the data structures
<ul>
<li>container functions are primitive operations performed on the containers like push, pop</li>
</ul>
</li>
<li>algorithms are complex operations performed on the containers like search, sort</li>
<li>iterators are used to access containers in a simpler way</li>
</ul>
</li>
<li>
<p>to import all the containers and common header files like iostream etc, use <code>#include&lt;bits/stdc++.h&gt;</code></p>
</li>
<li>
<p>insert vs emplace</p>
<ul>
<li>all containers might not have push operation but all have insert and emplace operations
<ul>
<li>both are same when using primitive data types</li>
<li>but when we use structs or objects emplace is more efficient</li>
<li>when we use insert it calls thee constructor of the struct or object then it copies the struct or object and this copy is inserted</li>
<li>emplace just copies the object without constructing it</li>
</ul>
</li>
</ul>
</li>
<li>
<p><mark style="background: #D2B3FFA6;">Containers</mark></p>
<ol>
<li><mark style="background: #BBFABBA6;">array</mark>
<ul>
<li>inside the array template class a primitive array is used and <code>.data()</code> is a function that returns that underlying primitive array</li>
<li>an STL array can be indexed using overloaded <code>[]</code> operator or using <code>.at(x)</code> function
<ul>
<li><code>.at(x)</code> function will throw an exception if the index is out of bounds but <code>[]</code> will give garbage value instead</li>
</ul>
</li>
<li>length provided during declaration has to be a constant and can never be a variable so you cant user input the length
<ul>
<li>these arrays can be passed by value to a function without any decay as the size can be found out by <code>.size()</code> function and the size is always known before compile time</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; arr.at(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 1</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; arr.front() &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; arr.back() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 10 returns the last element of the array container</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; arr.size();          <span class="hljs-comment">// 10 len of array</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; *arr.begin() &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 1 returns the address of the first element of the array container and is used for looping</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *(arr.end() - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 10</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *arr.rbegin() &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 10</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *(arr.rend() - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; arr.empty() &lt;&lt; <span class="hljs-built_in">endl</span>;       <span class="hljs-comment">// 0 checks if the array container is empty or not</span>

    <span class="hljs-comment">// cout&lt;&lt;arr.swap(anotherArrContainer);</span>

    arr.fill(<span class="hljs-number">7</span>); <span class="hljs-comment">// array has all 10 elements equal to 7 and fill function is used to initialise</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">vector</mark>
<ul>
<li>its a large array but not a linked list so when the array is filled then a new array is created and all the contents of the older array is copied to the new array</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;

    v.push_back(<span class="hljs-number">1</span>); <span class="hljs-comment">// {1}</span>
    v.push_back(<span class="hljs-number">2</span>); <span class="hljs-comment">// {1, 2}</span>

    <span class="hljs-comment">// emplace_back is faster than push_back</span>
    v.emplace_back(<span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span>
    v.emplace_back(<span class="hljs-number">4</span>); <span class="hljs-comment">// [1, 2, 3, 4]</span>
    v.emplace_back(<span class="hljs-number">5</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>
    v.emplace_back(<span class="hljs-number">6</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span>

    v.erase(v.end() - <span class="hljs-number">1</span>); <span class="hljs-comment">// to remove last element [1, 2, 3, 4, 5]</span>
    v.erase(v.begin());   <span class="hljs-comment">// removes 1st element [2, 3, 4, 5]</span>
    <span class="hljs-comment">// v.erase(startingIndexAddress,AdrOfLastElementToBeDeleted+1) can erase a range of elements if you provide</span>

    v.insert(v.begin(), <span class="hljs-number">0</span>); <span class="hljs-comment">// [0, 2, 3, 4, 5]</span>
    <span class="hljs-comment">// v.insert(address,howManyCopiesOf,ThisElement);</span>
    <span class="hljs-comment">// to insert vector cpy into v: v.insert(Address, cpy.begin(),cpy.endl);</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; v.front() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 0 5</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = v.begin(); itr != v.end(); itr++) <span class="hljs-comment">// 0 2 3 4 5</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; *itr &lt;&lt; <span class="hljs-string">" "</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = v.rbegin(); itr != v.rend(); itr++) <span class="hljs-comment">// 5 4 3 2 0</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; *itr &lt;&lt; <span class="hljs-string">" "</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    v.assign({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>});
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) <span class="hljs-comment">// 1 2 3 4 5</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// v.capacity() is the max length of the vector including buffer capacity</span>
    <span class="hljs-comment">// v.resize() changes the size and not the capacity but can change capacity if the size is full</span>
    <span class="hljs-comment">// v.reserve(1000) changes the capacity so that the vector doesn't resize till we push 1000 elements </span>
    <span class="hljs-comment">// v.clear() resets the vector</span>
    <span class="hljs-comment">// v.shrink_to_fit() releases unused memory</span>
    <span class="hljs-comment">// v.at(), v.swap(), v.data(), v.empty(), v.size() is same as arrays</span>

    <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; vpair;
    vpair.push_back({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>});  <span class="hljs-comment">// need to use flower braces to specify a pair</span>
    vpair.emplace_back(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// automatically infers that it is a pair with emplace_back</span>

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">hundred</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// creates {100,100,100,100,100}</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bydefault</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;    <span class="hljs-comment">// creates {0,0,0,0,0}</span>

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(v)</span></span>; <span class="hljs-comment">// creates a seperate copy of v and names it temp</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">list</mark>
<ul>
<li>doubly linked list</li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/DLL1.png" alt="doubly linked list"></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; ls; <span class="hljs-comment">// same as vector but also allows front operations</span>
    ls.push_back(<span class="hljs-number">2</span>);
    ls.emplace_back(<span class="hljs-number">4</span>);
    ls.push_front(<span class="hljs-number">0</span>);
    ls.emplace_front(<span class="hljs-number">-2</span>);
    ls.pop_front();
    ls.pop_back();
    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; ls2;
    ls.splice(ls.begin(), ls2); <span class="hljs-comment">// this will slice ls from ls.begin() and merge the sliced part with ls2</span>
    ls.unique();  <span class="hljs-comment">// will remove all duplicates from ls only if the duplicates are adjacent in positions so you might want to sort beforehand</span>
    ls.remove(<span class="hljs-number">2</span>); <span class="hljs-comment">// will remove all occurances of 2 from the ls</span>
    ls.remove_if([] (<span class="hljs-keyword">int</span> n) { <span class="hljs-comment">// lamda function that removes all values grtr than 4 from the list </span>
		<span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">4</span>;
	});
	ls.resize(<span class="hljs-number">2</span>); <span class="hljs-comment">// resizes the list to 2 so if there are more than 2 elements they are deleted otherwise the list is extended with values 0</span>
    ls.sort();    <span class="hljs-comment">// O(n log(n)) </span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">forward list</mark>
<ul>
<li>same as list but singly linked list instead</li>
<li>can traverse only in one direction</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">dequeue</mark>
<ul>
<li>doubly ended queues are queues but elements can be pushed and popped from both ends
<ul>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/deque.png" alt="dequeue"></li>
</ul>
</li>
<li>kinda like vectors but contiguous memory allocations is not guaranteed but front operations are allowed along with back operations</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq;
    <span class="hljs-comment">// dq.assign();</span>
    <span class="hljs-comment">// dq.at();</span>
    <span class="hljs-comment">// dq.front();</span>
    <span class="hljs-comment">// dq.back();</span>
    <span class="hljs-comment">// dq.begin();</span>
    <span class="hljs-comment">// dq.end();</span>
    <span class="hljs-comment">// dq.emplace_back();</span>
    <span class="hljs-comment">// dq.emplace_front();</span>
    <span class="hljs-comment">// dq.pop_back();</span>
    <span class="hljs-comment">// dq.push_front();</span>

    <span class="hljs-comment">// dq.clear();</span>
    <span class="hljs-comment">// dq.empty();</span>
    <span class="hljs-comment">// dq.erase();</span>

    <span class="hljs-comment">// dq.insert();</span>
    <span class="hljs-comment">// dq.resize();</span>
    <span class="hljs-comment">// dq.shrink_to_fit();</span>
    <span class="hljs-comment">// dq.size();</span>
    <span class="hljs-comment">// dq.swap();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">priority queue</mark>
<ul>
<li>also called max heap
<ul>
<li>like a heap(FIFO) that stores the largest element on the top</li>
</ul>
</li>
<li>pop deletes the largest element</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    priority_queue&lt;<span class="hljs-keyword">int</span>&gt; pq;
    <span class="hljs-comment">// pq.emplace(); // emplace_back obviously as no front operations possible</span>
    <span class="hljs-comment">// pq.empty();</span>
    <span class="hljs-comment">// pq.pop(); // removes largest element</span>
    <span class="hljs-comment">// pq.push();</span>
    <span class="hljs-comment">// pq.size();</span>
    <span class="hljs-comment">// pq.swap();</span>
    <span class="hljs-comment">// pq.top(); // returns the topmost element of the heap which it the largest one</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">stack</mark>
<ul>
<li>LIFO</li>
<li>stack of washed plates</li>
<li>same functions as priority_queue</li>
<li>push adds new element at the top of the stack</li>
<li>pop removes the topmost element</li>
<li>top reads the topmost element</li>
<li>useful for reversing without recursion</li>
<li>insert and delete happens from the same end</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// reverse string using stack</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">int</span> len)</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; strack;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        strack.push(str[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
    {
        str[i] = strack.top();
        strack.pop();
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">char</span> str[<span class="hljs-number">50</span>];
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter String: "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; str;
    reverse(str, <span class="hljs-built_in">strlen</span>(str));
    <span class="hljs-built_in">cout</span> &lt;&lt; str;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li><mark style="background: #FF5582A6;">bracket balancing</mark>
<ul>
<li>in code editors the linter checks if an opening bracket in a expression is closed before the expression ends</li>
<li>this operation uses stack and is called check for balanced parenthesis</li>
<li>every opening bracket should have a closing pair so that it is balanced and expression is valid</li>
<li>saying number of opening brackets should be equal to number of closing ones is incomplete as <code>)a+b(</code> or <code>[(])</code> are invalid</li>
<li>so the rules are:
<ul>
<li>an opening bracket should have a closing one to its right and not its left</li>
<li>a bracket can be closed only if all the brackets opened inside it are already closed</li>
<li>last unclosed bracket should be closed first <code>[()()]</code></li>
<li>scan from left to right</li>
<li>if opening bracket add it to the stack and if closing found then remove the topmost closing bracket type from the stack</li>
<li>at the end the stack should be empty to conclude the expression as valid</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">queue</mark>
<ul>
<li>FIFO</li>
<li>more used than stack irl</li>
<li>used when there is a shared resource and it can only handle only one resource at a time like a printer or a processor</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-comment">// q.front();</span>
    <span class="hljs-comment">// q.back();</span>
    <span class="hljs-comment">// q.empty();</span>
    <span class="hljs-comment">// q.pop();</span>
    <span class="hljs-comment">// q.push();</span>
    <span class="hljs-comment">// q.size();</span>
    <span class="hljs-comment">// q.swap();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li><mark style="background: #BBFABBA6;">set</mark>
<ul>
<li>no duplicates so every element in a set is unique</li>
<li>stored in ascending by default implemented using red-black/AVL tree
<ul>
<li><code>set&lt;int, greater&lt;&gt;&gt;</code> stores the elements in descending order</li>
</ul>
</li>
<li>but if we are providing objects/structs as template type then we need comparator as the set is implemented using a Binary Search Tree which needs a comparator for objects/structs sorting<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> roll;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> student &amp;rhs) <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> roll &lt; rhs.roll; } <span class="hljs-comment">// default ascending comparator</span>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> student &amp;rhs) <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> roll &gt; rhs.roll; } <span class="hljs-comment">// default descending comparator</span>
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Asc:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">set</span>&lt;student&gt; grade1 = {{<span class="hljs-string">"A"</span>, <span class="hljs-number">4</span>}, {<span class="hljs-string">"B"</span>, <span class="hljs-number">8</span>}, {<span class="hljs-string">"C"</span>, <span class="hljs-number">16</span>}, {<span class="hljs-string">"D"</span>, <span class="hljs-number">32</span>}};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : grade1)
        <span class="hljs-built_in">cout</span> &lt;&lt; x.name &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; x.roll &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Desc:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">set</span>&lt;student, <span class="hljs-built_in">std</span>::greater&lt;&gt;&gt; grade2 = {{<span class="hljs-string">"A"</span>, <span class="hljs-number">4</span>}, {<span class="hljs-string">"B"</span>, <span class="hljs-number">8</span>}, {<span class="hljs-string">"C"</span>, <span class="hljs-number">16</span>}, {<span class="hljs-string">"D"</span>, <span class="hljs-number">32</span>}};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : grade2)
        <span class="hljs-built_in">cout</span> &lt;&lt; x.name &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; x.roll &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><div>  	<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
  	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
  	</span>{
  	    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;
  	
  	    <span class="hljs-comment">// s.count(); // returns number of occurences of an element in the set and makes sense only for multisets as fo sets it is always 1</span>
  	
  	    <span class="hljs-comment">// s.find(); // returns iterator pointing to the desired element and returns s.end() if not found</span>
  	    <span class="hljs-comment">// s.insert(); // element to be inserted is passed and it returns a pair of the iterator pointing to place where it might be inserted, bool if it was inserted or not</span>
  	
  	    <span class="hljs-comment">// s.emplace();</span>
  	    <span class="hljs-comment">// s.begin();</span>
  	    <span class="hljs-comment">// s.end();</span>
  	    <span class="hljs-comment">// s.clear();</span>
  	    <span class="hljs-comment">// s.empty();</span>
  	    <span class="hljs-comment">// s.erase();</span>
  	    <span class="hljs-comment">// s.size();</span>
  	    <span class="hljs-comment">// s.swap();</span>
  	    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  	}
  	```
  <span class="hljs-number">10.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;<span class="hljs-built_in">multiset</span>&lt;/mark&gt;
  	- same as <span class="hljs-built_in">set</span> with the same functions but allows duplicate entries <span class="hljs-keyword">and</span> still are sorted
  	- `.equal_range(key)` used with <span class="hljs-keyword">auto</span> returns an iterable container of values as the same key can have multiple values so we can use <span class="hljs-keyword">auto</span> with <span class="hljs-keyword">for</span> each loop to print all values of <span class="hljs-keyword">this</span> container
  		- prefer <span class="hljs-keyword">using</span> <span class="hljs-keyword">auto</span> as the <span class="hljs-keyword">return</span> type is pair of <span class="hljs-number">2</span> iterators where one is <span class="hljs-keyword">for</span> the keys <span class="hljs-keyword">and</span> the other <span class="hljs-keyword">for</span> values
  	- use <span class="hljs-keyword">this</span> instead of <span class="hljs-built_in">map</span> of key <span class="hljs-keyword">and</span> <span class="hljs-built_in">vector</span> value 
  <span class="hljs-number">11.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;<span class="hljs-built_in">map</span>&lt;/mark&gt;
  	- like arrays but the indices are called keys <span class="hljs-keyword">and</span> keys can be of any data type
  	- stores key-value pairs <span class="hljs-keyword">and</span> all keys must be unique <span class="hljs-keyword">and</span> keys are stored in sorted order
  	- functions like <span class="hljs-built_in">set</span>
  	- need to specify comparator a <span class="hljs-keyword">template</span> type is a struct/object as it is implemented <span class="hljs-keyword">using</span> red-black/AVL tree
  	- `.first` gives the key <span class="hljs-keyword">and</span> `.second` gives the value when <span class="hljs-keyword">using</span> an iterator
  	- `someMap[key]` returns value
  	- keys are immutable <span class="hljs-keyword">and</span> values are <span class="hljs-keyword">mutable</span>
  	- insertion <span class="hljs-keyword">requires</span> passing of a pair as a parameter like `.insert(make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>))` where the type of pair is inferred automatically
  		- otherwise the type of the pair can be explicitly provided like `.insert(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>))`
  <span class="hljs-number">12.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;<span class="hljs-built_in">multimap</span>&lt;/mark&gt;
  	- same as a <span class="hljs-built_in">map</span> but allows duplicate keys but the key-value pairs must be unique
  		- hence `.at()` function <span class="hljs-keyword">not</span> available
  <span class="hljs-number">13.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;unordered <span class="hljs-built_in">map</span>&lt;/mark&gt;
  	- like <span class="hljs-built_in">map</span> but keys are <span class="hljs-keyword">not</span> stored in sorted order
  	- has some unique bucket functions
  <span class="hljs-number">14.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;pairs <span class="hljs-keyword">and</span> nested pairs&lt;/mark&gt; 
  	```cpp
  		#include &lt;bits/stdc++.h&gt;
  		<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
  		<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
  		</span>{
  		    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
  		    <span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-built_in">endl</span>;
  		    pair&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; np = {p, <span class="hljs-number">3</span>};
  		    <span class="hljs-built_in">cout</span> &lt;&lt; np.first.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; np.first.second &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; np.second &lt;&lt; <span class="hljs-built_in">endl</span>;
  	
  		    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pairray[] = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>}, {<span class="hljs-number">7</span>, <span class="hljs-number">8</span>}};
  		    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(pairray) / <span class="hljs-number">8</span>; i++)
  		        <span class="hljs-built_in">cout</span> &lt;&lt; pairray[i].first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; pairray[i].second &lt;&lt; <span class="hljs-built_in">endl</span>;
  		    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  		}	
  	```
  <span class="hljs-number">15.</span> &lt;mark style=<span class="hljs-string">"background: #BBFABBA6;"</span>&gt;tree&lt;/mark&gt;
  	- a <span class="hljs-built_in">vector</span> of <span class="hljs-built_in">vector</span> can be interpreted as a STL tree
  		- every element in the parent <span class="hljs-built_in">vector</span> is a child <span class="hljs-built_in">vector</span>
  		- the index of the parent <span class="hljs-built_in">array</span> represents the parent node of the tree <span class="hljs-keyword">and</span> the associated <span class="hljs-built_in">vector</span> stores the child node of the parent
  	```cpp
  	#include &lt;bits/stdc++.h&gt;
  	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
  	
  	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
  	</span>{
  	    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; tree;
  	    <span class="hljs-keyword">int</span> edge, parentIndex, childValue;
  	    <span class="hljs-built_in">cin</span> &gt;&gt; edge; <span class="hljs-comment">// = len of the parent vector</span>
  	    tree.resize(edge + <span class="hljs-number">1</span>);
  	
  	    <span class="hljs-comment">// to populate the tree</span>
  	    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= edge; ++i)
  	    {
  	        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter Parent Index: "</span>;
  	        <span class="hljs-built_in">cin</span> &gt;&gt; parentIndex;
  	        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter the value it points to: "</span>;
  	        <span class="hljs-built_in">cin</span> &gt;&gt; childValue;
  	        tree[parentIndex].push_back(childValue);
  	        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
  	    }
  	
  	    <span class="hljs-keyword">int</span> ctr = <span class="hljs-number">0</span>;
  	    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;p : tree)
  	    {
  	        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nParent Node "</span> &lt;&lt; ctr++ &lt;&lt; <span class="hljs-string">": points to children nodes "</span>;
  	        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;c : p)
  	            <span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">" "</span>;
  	    }
  	    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  	}
  	<span class="hljs-comment">/*
  	9
  	Enter Parent Index: 1
  	Enter the value it points to: 2
  	
  	Enter Parent Index: 1
  	Enter the value it points to: 3
  	
  	Enter Parent Index: 2
  	Enter the value it points to: 4
  	
  	Enter Parent Index: 2
  	Enter the value it points to: 5
  	
  	Enter Parent Index: 3
  	Enter the value it points to: 6
  	
  	Enter Parent Index: 3
  	Enter the value it points to: 8
  	
  	Enter Parent Index: 4
  	Enter the value it points to: 0
  	
  	Enter Parent Index: 5
  	Enter the value it points to: 0
  	
  	Enter Parent Index: 6
  	Enter the value it points to: 0
  	
  	Enter Parent Index: 8
  	Enter the value it points to: 0
  	
  	
  	Parent Node 0: points to children nodes
  	Parent Node 1: points to children nodes 2 3
  	Parent Node 2: points to children nodes 4 5
  	Parent Node 3: points to children nodes 6 8
  	Parent Node 4: points to children nodes 0
  	Parent Node 5: points to children nodes 0
  	Parent Node 6: points to children nodes 0
  	Parent Node 7: points to children nodes
  	Parent Node 8: points to children nodes 0
  	Parent Node 9: points to children nodes
  	*/</span>
  	```
  	- ![tree created](https:<span class="hljs-comment">//raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-02-20%2010-17-53.png)</span>
</div></code></pre>
</li>
<li>
<p><mark style="background: #D2B3FFA6;">Iterators</mark></p>
<ul>
<li>there are different iterators for different containers</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// vector&lt;int&gt; v;  by default creates a vector of len 16</span>
    <span class="hljs-comment">// vector&lt;int&gt; v(50); creates a vector of len 50</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">456</span>, <span class="hljs-number">7890</span>};
    v.push_back(<span class="hljs-number">56</span>); <span class="hljs-comment">// added 56 at the end after 7890</span>
    v.push_back(<span class="hljs-number">69</span>); <span class="hljs-comment">// added 69 at the end after 56</span>
    v.pop_back();    <span class="hljs-comment">// last element is removed</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : v)
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itr = v.begin(); itr != v.end(); itr++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *itr &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// becoz itr is a ptr which uses ptr arithmetic</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-comment">// we can replace occurences of vector with list or forward_list or dequeue or set and not other changes are needed</span>
</div></code></pre>
<ul>
<li>using maps</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; m;
    m.insert(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">"john"</span>));
    m.insert(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-string">"ravi"</span>));
    m.insert(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">"khan"</span>));

    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator itr;
    <span class="hljs-keyword">for</span> (itr = m.begin(); itr != m.end(); itr++)
        <span class="hljs-built_in">cout</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; itr-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator itr1;
    itr1 = m.find(<span class="hljs-number">2</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"value found: "</span> &lt;&lt; itr1-&gt;first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; itr1-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
</ul>
<h1 id="mark-style%22background-ffb86ca6%22cdt-concrete-data-typesmark"><mark style="background: #FFB86CA6;">CDT: Concrete Data Types</mark></h1>
<p><mark style="background: #D2B3FFA6;">Array</mark></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">concreteArray</span>
{</span>
    <span class="hljs-keyword">int</span> *arrptr, size, len;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>;

<span class="hljs-keyword">public</span>:
    concreteArray(<span class="hljs-keyword">int</span> size = <span class="hljs-number">10</span>)
    {
        <span class="hljs-keyword">this</span>-&gt;size = size;
        len = <span class="hljs-number">0</span>;
        arrptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];
    }
    ~concreteArray()
    {
        <span class="hljs-keyword">delete</span>[] arrptr;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span>, <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>, <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span>, <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">string</span>)</span>, <span class="hljs-title">ReverseMethodOne</span><span class="hljs-params">()</span>, <span class="hljs-title">ReverseMethodTwo</span><span class="hljs-params">()</span>, <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">string</span>)</span>, <span class="hljs-title">LinearSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span>, <span class="hljs-title">BinarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span>, <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span>, <span class="hljs-title">Min</span><span class="hljs-params">()</span>, <span class="hljs-title">Max</span><span class="hljs-params">()</span>, <span class="hljs-title">Sum</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Avg</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSorted</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::Print</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array is empty"</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"[ "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; arrptr[i] &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::Append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (len == size)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array is full, cannot append"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    arrptr[len] = x;
    len++;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (len == size)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array is full, cannot insert"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; len)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Invalid index"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len; i &gt; index; i++)
        arrptr[i] = arrptr[i - <span class="hljs-number">1</span>];
    arrptr[index] = x;
    len++;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">string</span>)</span>
</span>{
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; len)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Invalid index"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"badIndex"</span>);
    }
    <span class="hljs-keyword">int</span> deletedValue = arrptr[index];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; len - <span class="hljs-number">1</span>; i++)
        arrptr[i] = arrptr[i + <span class="hljs-number">1</span>];
    len--;
    <span class="hljs-keyword">return</span> deletedValue;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span>
</span>{
    <span class="hljs-keyword">int</span> temp = *x;
    *x = *y;
    *y = temp;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::LinearSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-keyword">if</span> (arrptr[i] == key)
        {
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)
                swap(&amp;arrptr[i], &amp;arrptr[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">return</span> i;
        }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::BinarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span>
</span>{
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = len - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (l &lt;= h)
    {
        <span class="hljs-keyword">int</span> mid = (l + h) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (key == arrptr[mid])
            <span class="hljs-keyword">return</span> mid;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; arrptr[mid])
            h = mid - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            l = mid + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::Get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{ <span class="hljs-keyword">return</span> (index &lt; <span class="hljs-number">0</span> || index &gt; len) ? <span class="hljs-number">-1</span> : arrptr[index]; }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::Set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">string</span>)</span>
</span>{
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; len)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Invalid index"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"badIndex"</span>);
    }
    arrptr[index] = x;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::Max</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> max = arrptr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)
        max = arrptr[i] &gt; max ? arrptr[i] : max;
    <span class="hljs-keyword">return</span> max;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::Min</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> min = arrptr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)
        min = arrptr[i] &lt; min ? arrptr[i] : min;
    <span class="hljs-keyword">return</span> min;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concreteArray::Sum</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> sum = arrptr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)
        sum += arrptr[i];
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">concreteArray::Avg</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>)(Sum() / len); }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::ReverseMethodOne</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> *temparrptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        temparrptr[len - <span class="hljs-number">1</span> - i] = arrptr[i];
    <span class="hljs-keyword">delete</span>[] arrptr;
    arrptr = temparrptr;
    temparrptr = <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::ReverseMethodTwo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        swap(&amp;arrptr[i], &amp;arrptr[len - <span class="hljs-number">1</span> - i]);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">concreteArray::InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (len == size)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array is full, cannot insert"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; arrptr[i] &gt; x; i--)
        arrptr[i + <span class="hljs-number">1</span>] = arrptr[i];
    arrptr[i + <span class="hljs-number">1</span>] = x;
    len++;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">concreteArray::isSorted</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)
        <span class="hljs-keyword">if</span> (arrptr[i] &gt; arrptr[i + <span class="hljs-number">1</span>])
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p><mark style="background: #D2B3FFA6;">Singly Linked List</mark></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>
{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
    {</span>
        <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;
        node *next = <span class="hljs-literal">nullptr</span>;
    } *head = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minmax</span>
    {</span>
        <span class="hljs-keyword">int</span> min = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;
        minmax() = <span class="hljs-keyword">default</span>;                      <span class="hljs-comment">// default constructor, gerenated automatically but not when there is a parametrized constructor declared</span>
        minmax(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) : min(x), max(y) {} <span class="hljs-comment">// parametrized constructor for the struct</span>
    };
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-function">minmax <span class="hljs-title">findMinMax</span><span class="hljs-params">(node *p)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dupliDeleter</span><span class="hljs-params">()</span></span>;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>)</span> <span class="hljs-comment">// explicit can be used with any constructor that takes a single argument to avoid unexpected behaviour</span>
    </span>{
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Length of Linked List cannot be smaller than 1"</span>;
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
        }
        len = n;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"insert at beginning of the Linked List: elements that are filled first get pushed towards the end"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len; i &gt; <span class="hljs-number">0</span>; i--)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter element "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span>;
            node *tmp = <span class="hljs-keyword">new</span> node;
            <span class="hljs-built_in">cin</span> &gt;&gt; tmp-&gt;data;
            tmp-&gt;next = head; <span class="hljs-comment">// tmp-&gt;next now points at the 1st node of the linked list while the head is also pointing at it</span>
            head = tmp;       <span class="hljs-comment">// head now points at the new node tmp and tmp-&gt;next was already pointing to the node that was previously the first node</span>
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nThe constructed Linked List of length "</span> &lt;&lt; len &lt;&lt; <span class="hljs-string">" is:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        printLinkedList();
    }
    LinkedList(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)
    {
        len = n;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"creating Linked List from array elements"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        {
            node *tmp = <span class="hljs-keyword">new</span> node;
            tmp-&gt;data = arr[i];
            tmp-&gt;next = head;
            head = tmp;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nThe constructed Linked List of length "</span> &lt;&lt; len &lt;&lt; <span class="hljs-string">" is:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        printLinkedList();
    }
    ~LinkedList()
    {
	    node *tmp=head;
		<span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>)
		{
			head = head-&gt;next;
			<span class="hljs-keyword">delete</span> tmp;
			tmp = head;
		}
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span>, <span class="hljs-title">recursivePrintLinkedList</span><span class="hljs-params">(node *p)</span>, <span class="hljs-title">insertDataAt</span><span class="hljs-params">()</span>, <span class="hljs-title">deleteDataAt</span><span class="hljs-params">()</span>, <span class="hljs-title">printMinMax</span><span class="hljs-params">()</span>, <span class="hljs-title">swappyLinearSearch</span><span class="hljs-params">()</span>, <span class="hljs-title">amIsorted</span><span class="hljs-params">()</span>, <span class="hljs-title">reverseByLinkFlipBySlidingPointers</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recursiveAdd</span><span class="hljs-params">(node *p)</span></span>;
    <span class="hljs-function">node *<span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> head; }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::printLinkedList</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// cannot iterate directly using head otherwise we will lose its orignal value while incrementing when traversing Linked List</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The Head points to ["</span> &lt;&lt; head &lt;&lt; <span class="hljs-string">"] and"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">int</span> ctr = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (node *itr = head; itr != <span class="hljs-literal">nullptr</span>; itr = itr-&gt;next)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Node Number "</span> &lt;&lt; ctr++ &lt;&lt; <span class="hljs-string">": This is ["</span> &lt;&lt; itr &lt;&lt; <span class="hljs-string">"]\t storing "</span> &lt;&lt; itr-&gt;data &lt;&lt; <span class="hljs-string">"\t and the next address is 👉 ["</span> &lt;&lt; itr-&gt;next &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::recursivePrintLinkedList</span><span class="hljs-params">(node *p)</span>
</span>{
    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ctr = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Node Number "</span> &lt;&lt; ctr++ &lt;&lt; <span class="hljs-string">": This is ["</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"]\t storing "</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">"\t and the next address is 👉 ["</span> &lt;&lt; p-&gt;next &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        recursivePrintLinkedList(p-&gt;next);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::insertDataAt</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// to insert a new node at the position pos we create a tmp node that is to be inserted</span>
    <span class="hljs-comment">// and then make the next of pos-1 th node point to it and store (pos-1)-&gt;next in tmp-&gt;next</span>
    <span class="hljs-keyword">int</span> pos;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEnter Insertion point: "</span>;
        <span class="hljs-built_in">cin</span> &gt;&gt; pos;
    } <span class="hljs-keyword">while</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; len);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter Value to be inserted at Node Number "</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">": "</span>;
    node *tmp = <span class="hljs-keyword">new</span> node;
    <span class="hljs-built_in">cin</span> &gt;&gt; tmp-&gt;data;
    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">1</span>)
    {
        tmp-&gt;next = head;
        head = tmp;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">// lets go to the pos-1 th node</span>
        node *itr = head;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pos - <span class="hljs-number">2</span>; i++)
            itr = itr-&gt;next;
        tmp-&gt;next = itr-&gt;next;
        itr-&gt;next = tmp;
    }
    len++;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added "</span> &lt;&lt; tmp-&gt;data &lt;&lt; <span class="hljs-string">" at Node Number "</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">" pushing the nodes after it 1 place ahead\n\n"</span>;
    printLinkedList();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::deleteDataAt</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// to delete an existing node you need to link the node before and after it by making the next of node before it point to the node after it</span>
    <span class="hljs-comment">// remember to free the deleted node at the end else it will be a memory leak</span>
    <span class="hljs-keyword">int</span> pos;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEnter Node Number to be deleted: "</span>;
        <span class="hljs-built_in">cin</span> &gt;&gt; pos;
    } <span class="hljs-keyword">while</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; len);
    node *before = head;
    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">1</span>)
    {
        head = before-&gt;next;
        <span class="hljs-keyword">delete</span> before;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pos - <span class="hljs-number">2</span>; i++)
        before = before-&gt;next;
    node *after = before-&gt;next-&gt;next;
    <span class="hljs-keyword">delete</span> before-&gt;next;
    before-&gt;next = after;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Deleted Node Number "</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">" pulling the nodes after it 1 place behind\n\n"</span>;
    printLinkedList();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkedList::recursiveAdd</span><span class="hljs-params">(node *p)</span>
</span>{
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> recursiveAdd(p-&gt;next) + p-&gt;data;
}

<span class="hljs-function">LinkedList::minmax <span class="hljs-title">LinkedList::findMinMax</span><span class="hljs-params">(node *p)</span>
</span>{
    <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> {INT_MAX, INT_MIN}; <span class="hljs-comment">// parametrized constructor handles it</span>
    minmax mm = findMinMax(p-&gt;next);
    <span class="hljs-keyword">return</span> {mm.min &gt; p-&gt;data ? p-&gt;data : mm.min, mm.max &lt; p-&gt;data ? p-&gt;data : mm.max};
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::printMinMax</span><span class="hljs-params">()</span>
</span>{
    minmax <span class="hljs-keyword">final</span> = findMinMax(head);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nThe smallest value is "</span> &lt;&lt; <span class="hljs-keyword">final</span>.min &lt;&lt; <span class="hljs-string">" and the largest value is "</span> &lt;&lt; <span class="hljs-keyword">final</span>.max &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::swappyLinearSearch</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">/**
     * a swappy linear search is a variation of linear search
     * where if we find the key in a node we move the node to the start
     * so that the next time searching will be quicker
     *
     * we have to iterators p and q such that q is always one node behind p
     * when we find the key at p we link q node-&gt;next to p node-&gt;next
     * and copy head into p node-&gt;next and make head point to p node now
     */</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEnter Query: "</span>;
    <span class="hljs-keyword">int</span> key;
    <span class="hljs-built_in">cin</span> &gt;&gt; key;
    node *p = head, *q = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">if</span> (key == p-&gt;data)
        {
            q-&gt;next = p-&gt;next;
            p-&gt;next = head;
            head = p;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Found! Pulled to head"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            printLinkedList();
            <span class="hljs-keyword">return</span>;
        }
        q = p;
        p = p-&gt;next;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not Found"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::amIsorted</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">int</span> compare = INT_MIN;
    <span class="hljs-keyword">for</span> (node *itr = head; itr != <span class="hljs-literal">nullptr</span>; itr = itr-&gt;next)
    {
        <span class="hljs-keyword">if</span> (itr-&gt;data &lt; compare)
        {
            flag = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">break</span>;
        }
        compare = itr-&gt;data;
    }
    <span class="hljs-keyword">if</span> (flag)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nLinked List is sorted, Lets check for duplicates"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        dupliDeleter();
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nLinked List is not sorted"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::dupliDeleter</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;
    node *p = head, *q = head-&gt;next;
    <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">if</span> (p-&gt;data != q-&gt;data)
        {
            p = q;
            q = q-&gt;next;
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-comment">// below lines are executed when p-&gt;data == q-&gt;data</span>
        p-&gt;next = q-&gt;next;
        <span class="hljs-keyword">delete</span> q;
        flag = <span class="hljs-literal">true</span>;
        q = p-&gt;next;
    }
    <span class="hljs-keyword">if</span> (flag)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Deleted found duplicates"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        printLinkedList();
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"No Duplicates were found"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LinkedList::reverseByLinkFlipBySlidingPointers</span><span class="hljs-params">()</span>
</span>{
    node *p = head, *q = <span class="hljs-literal">nullptr</span>, *r = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)
    {
        r = q;
        q = p;
        p = p-&gt;next;
        q-&gt;next = r;
    }
    head = q;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nLinked List stored in reverse"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printLinkedList();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// int arr[] = {4, 8, 16, 32, 64};</span>
    <span class="hljs-comment">// LinkedList linkls(arr, 5);</span>
    LinkedList linkls;
    linkls.insertDataAt();
    linkls.deleteDataAt();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nPrinting the Linked List recursively"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    linkls.recursivePrintLinkedList(linkls.getHead());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nThe sum of all elemets is "</span> &lt;&lt; linkls.recursiveAdd(linkls.getHead()) &lt;&lt; <span class="hljs-built_in">endl</span>;
    linkls.printMinMax();
    linkls.swappyLinearSearch();
    linkls.amIsorted();
    linkls.reverseByLinkFlipBySlidingPointers();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p><mark style="background: #D2B3FFA6;">Circular Linked list</mark></p>
<ul>
<li>the last node of the linked list points to the head of the linked list instead of <code>nullptr</code></li>
<li>an empty linked list can never be circular as it needs at least one node and a head so that the head can point to node and node can point to the head
<ul>
<li>just like how a bidirectional arrow cannot point to the same dot and needs at least 2 dots</li>
</ul>
</li>
</ul>
<p><mark style="background: #D2B3FFA6;">Doubly Linked List</mark></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    node *prev, *next;
} *head = <span class="hljs-literal">NULL</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    node *tmp = <span class="hljs-keyword">new</span> node();
    tmp-&gt;data = x;
    tmp-&gt;prev = <span class="hljs-literal">NULL</span>;
    tmp-&gt;next = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// if the list is empty</span>
    {
        head = tmp;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// when the list is not empty</span>
    head-&gt;prev = tmp; <span class="hljs-comment">// establishing link in forward dirn</span>
    tmp-&gt;next = head; <span class="hljs-comment">// establishing link in backward dirn</span>
    head = tmp;       <span class="hljs-comment">// head should now point at the node we inserted</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fwdPrint</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span> (node *itr = head; itr != <span class="hljs-literal">NULL</span>; itr = itr-&gt;next)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"This is "</span> &lt;&lt; itr &lt;&lt; <span class="hljs-string">" having (prev="</span> &lt;&lt; itr-&gt;prev &lt;&lt; <span class="hljs-string">" data="</span> &lt;&lt; itr-&gt;data &lt;&lt; <span class="hljs-string">" next="</span> &lt;&lt; itr-&gt;next &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">revPrint</span><span class="hljs-params">()</span>
</span>{
    node *itr = head;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span>;               <span class="hljs-comment">// exit if empty list</span>
    <span class="hljs-keyword">while</span> (itr-&gt;next != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// to get to the last node</span>
        itr = itr-&gt;next;
    <span class="hljs-keyword">while</span> (itr != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"This is "</span> &lt;&lt; itr &lt;&lt; <span class="hljs-string">" having (prev="</span> &lt;&lt; itr-&gt;prev &lt;&lt; <span class="hljs-string">" data="</span> &lt;&lt; itr-&gt;data &lt;&lt; <span class="hljs-string">" next="</span> &lt;&lt; itr-&gt;next &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        itr = itr-&gt;prev;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"[1] Insert At Head\n[2] Print Forward\n[3] Print Reverse\n[4] Quit\n\n"</span>;
    <span class="hljs-keyword">int</span> ch;
restart:
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nChoice: "</span>;
        <span class="hljs-built_in">cin</span> &gt;&gt; ch;
    } <span class="hljs-keyword">while</span> (ch != <span class="hljs-number">1</span> &amp;&amp; ch != <span class="hljs-number">2</span> &amp;&amp; ch != <span class="hljs-number">3</span> &amp;&amp; ch != <span class="hljs-number">4</span>);
    <span class="hljs-keyword">switch</span> (ch)
    {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter Element: "</span>;
        <span class="hljs-keyword">int</span> x;
        <span class="hljs-built_in">cin</span> &gt;&gt; x;
        insertAtHead(x);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        fwdPrint();
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
        revPrint();
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">goto</span> restart;
}
</div></code></pre>
<p><mark style="background: #D2B3FFA6;">Binary Search Trees</mark></p>
<ul>
<li>is a binary tree with value of <mark style="background: #BBFABBA6;">left child node</mark> of a parent node always <mark style="background: #BBFABBA6;">smaller than or equal to</mark> the value of <mark style="background: #BBFABBA6;">parent node</mark> and the value of <mark style="background: #BBFABBA6;">right child node</mark> of a parent node always <mark style="background: #BBFABBA6;">larger than or equal to</mark> the value of <mark style="background: #BBFABBA6;">parent node</mark></li>
<li>used for effectively searching</li>
<li><mark style="background: #BBFABBA6;">recursion is used for common operations as tree has unidirectional next nodes, </mark> we use stack of activation record of function in recursive calls to remember the address of parental nodes</li>
<li>to check validity, n nodes = n-1 connecting links</li>
<li><mark style="background: #BBFABBA6;">depth</mark>
<ul>
<li>depth is measured <mark style="background: #BBFABBA6;">from the topmost node of the tree</mark></li>
<li>So <mark style="background: #BBFABBA6;">root of the tree has depth 0</mark></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">height</mark>
<ul>
<li>height of a node in a tree is equal to <mark style="background: #BBFABBA6;">the number of connecting links needed to reach that node from the furthest leaf(a node without any child) under that node</mark></li>
<li><mark style="background: #BBFABBA6;">height of all leaves is 0</mark></li>
<li><mark style="background: #BBFABBA6;">height of a tree is height of the topmost node of the tree</mark></li>
<li><mark style="background: #BBFABBA6;">height if an empty tree is -1</mark></li>
<li><mark style="background: #BBFABBA6;">height of a tree with one node is 0</mark> and so on</li>
<li><mark style="background: #BBFABBA6;">height if a tree with n nodes is n-1</mark> which is equal to the number of connecting links</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">max number of nodes for a node at height h</mark> <code>= (2^h)-1</code></li>
<li><mark style="background: #BBFABBA6;">a binary tree for which any node either has 2 or 0 nodes</mark> is called a <mark style="background: #BBFABBA6;">perfect binary tree and height of a perfect binary tree</mark> <code>= floor(log base2 of n)</code> where n is number of nodes</li>
<li><mark style="background: #BBFABBA6;">cost is proportional to the height of the tree</mark>
<ul>
<li>the <mark style="background: #BBFABBA6;">height is lesser if the tree is denser and a tree is denser if it is a perfect binary tree</mark></li>
<li>more a <mark style="background: #BBFABBA6;">binary tree is perfect, denser it is</mark></li>
<li><mark style="background: #BBFABBA6;">linked list is the most imperfect binary tree as every node will have one node</mark></li>
<li>tree operations are <code>O(height)</code> so for a perfect binary tree <code>O(log base2 of n)</code> and <code>O(n)</code> for a linked list</li>
<li>for tree <code>O(n)</code> is worse than <code>O(height)</code> as <code>height = log base2 of n</code></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">try keeping the tree balanced</mark>, a balanced tree is one <mark style="background: #BBFABBA6;">for which (ht of left child sub tree of parent) - (ht of right child sub tree of parent) = 0 or 1</mark></li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-23%2022-31-43.png" alt="binary tree array"></li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-23%2023-18-36.png" alt="why use binary search tree"></li>
<li>in a binary search tree <mark style="background: #BBFABBA6;">at every step you compare the value you are looking for with the value at the node and if it is match you stop</mark>
<ul>
<li><mark style="background: #BBFABBA6;">else you discard left or right sub tree after comparing</mark> the value you are looking for with the value at the current node</li>
</ul>
</li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-23%2023-29-47.png" alt="this is insertion"></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
    node *left;
    <span class="hljs-keyword">int</span> data;
    node *right;
} *rootptr = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// this points to the root node and is not the root node itself</span>

<span class="hljs-function">node *<span class="hljs-title">getsetNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span>
</span>{
    node *newNode = <span class="hljs-keyword">new</span> node();
    newNode-&gt;data = data;
    newNode-&gt;left = newNode-&gt;right = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *rootptr, <span class="hljs-keyword">int</span> data)</span>
</span>{
    <span class="hljs-keyword">if</span> (rootptr == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// breaking condition for recursion</span>
        rootptr = getsetNode(data);
    <span class="hljs-comment">// these ifs below help to locate the position for new node in the tree and the new node can only be inserted if the left or right of another node points to NULL</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt;= rootptr-&gt;data)
        rootptr-&gt;left = insert(rootptr-&gt;left, data);
    <span class="hljs-keyword">else</span>
        rootptr-&gt;right = insert(rootptr-&gt;right, data);
    <span class="hljs-keyword">return</span> rootptr;
}
<span class="hljs-comment">/**
 * for deleting a node which has 2 child subtree we find the min of right subtree and replace it with the node to be deleted and remove the duplicate in right tree
 * max of left is also allowed
 */</span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(node *rootptr, <span class="hljs-keyword">int</span> target)</span>
</span>{
    <span class="hljs-keyword">if</span> (rootptr == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rootptr-&gt;data == target)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt;= rootptr-&gt;data)
        <span class="hljs-keyword">return</span> search(rootptr-&gt;left, target);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> search(rootptr-&gt;right, target);
}

<span class="hljs-comment">/**
 * to find the ht of the tree: O(n) where n is the number of nodes
 * pseudo code
 * findht(root){
 *      if root is null return -1 // if we find a leaf node its ht will be 0 which is -1 + 1
 *      leftht=findht(root-&gt;left)
 *      rightht=findht(root-&gt;right)
 *      return (max of leftht and rightht)+1
 * }
 */</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findht</span><span class="hljs-params">(node *rootptr)</span>
</span>{
    <span class="hljs-keyword">if</span> (rootptr == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> leftht = findht(rootptr-&gt;left);
    <span class="hljs-keyword">int</span> rightht = findht(rootptr-&gt;right);
    <span class="hljs-keyword">return</span> leftht &gt; rightht ? leftht + <span class="hljs-number">1</span> : rightht + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">/**
 * bfs uses queue. s soon as we find a node we add its address to the queue
 * then u access it and pop the last node from queue and enqueue its child nodes
 * traversal is completed when the queue is empty
 * time complexity: O(n)
 * space complexity: O(n) in perfect tree or O(1) in linked list
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBFS</span><span class="hljs-params">(node *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">queue</span>&lt;node *&gt; q;
    q.push(root);
    <span class="hljs-keyword">while</span> (!q.empty())
    {
        node *current = q.front();
        <span class="hljs-built_in">cout</span> &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-keyword">if</span> (current-&gt;left != <span class="hljs-literal">NULL</span>)
            q.push(current-&gt;left);
        <span class="hljs-keyword">if</span> (current-&gt;right != <span class="hljs-literal">NULL</span>)
            q.push(current-&gt;right);
        q.pop();
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"[1] to insert\n[2] to search\n[3] to show ht\n[4] BFS print\n[5] to quit\n\n"</span>;
    <span class="hljs-keyword">int</span> ch;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        <span class="hljs-keyword">do</span>
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter choice: "</span>;
            <span class="hljs-built_in">cin</span> &gt;&gt; ch;
        } <span class="hljs-keyword">while</span> (ch != <span class="hljs-number">1</span> &amp;&amp; ch != <span class="hljs-number">2</span> &amp;&amp; ch != <span class="hljs-number">3</span> &amp;&amp; ch != <span class="hljs-number">4</span> &amp;&amp; ch != <span class="hljs-number">5</span>);
        <span class="hljs-keyword">switch</span> (ch)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Insert: "</span>;
            <span class="hljs-keyword">int</span> ins;
            <span class="hljs-built_in">cin</span> &gt;&gt; ins;
            rootptr = insert(rootptr, ins);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter Query: "</span>;
            <span class="hljs-keyword">int</span> query;
            <span class="hljs-built_in">cin</span> &gt;&gt; query;
            <span class="hljs-keyword">if</span> (search(rootptr, query))
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Found"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">else</span>
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NOT Found"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ht of BINARY SEARCH TREE IS "</span> &lt;&lt; findht(rootptr) &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            printBFS(rootptr);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
}
<span class="hljs-comment">/**
 * binary tree traversal is visiting all the elements of the tree exactly once
 * 2 ways
 * bfs is visiting all nodes at a level(top to bottom) from left to right
 * dfs if we area at a child then we completely visit the entire subtree of that child
 *      3 ways
 *      preorder    root-&gt;left subtree-&gt;right subtree short form data left right dlr
 *      inorder     left subtree-&gt;root-&gt;right subtree short form left data right dlr
 *      postorder   left subtree-&gt;right subtree-&gt;root short form left right data dlr
 *      data means read or access the data before moving to the next subtree
 */</span>
</div></code></pre>
<p><mark style="background: #D2B3FFA6;">Graphs</mark></p>
<ul>
<li><mark style="background: #BBFABBA6;">linked list and trees are also graphs</mark></li>
<li><mark style="background: #BBFABBA6;">graphs have no restrictions on connecting links between nodes</mark></li>
<li>a graph is represented as G=(V,E) where G is an ordered pair of vertices and edges
<ul>
<li><mark style="background: #BBFABBA6;">vertices are nodes</mark></li>
<li>an <mark style="background: #BBFABBA6;">edge is the connecting link between two nodes</mark>
<ul>
<li><mark style="background: #BBFABBA6;">an edge can be directed(one way) or undirected(two way)</mark></li>
<li><mark style="background: #BBFABBA6;">an edge can have weights like distance between two cities</mark>
<ul>
<li><mark style="background: #BBFABBA6;">when graph is weighted</mark> we cannot just rely on the number of edges between 2 vertices <mark style="background: #BBFABBA6;">to find the shortest path as we need to consider weights</mark></li>
<li><mark style="background: #BBFABBA6;">all weights for an unweighted graphs are 1</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">graph can have self loops</mark> <mark style="background: #BBFABBA6;">meaning vertex has an edge pointing to itself</mark>
<ul>
<li><mark style="background: #BBFABBA6;">like how many websites have links to the same page</mark> and that is an example of self loop</li>
<li><mark style="background: #BBFABBA6;">refresh page on the browser leads to the same page</mark></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">two vertices can have multiple edges between them example multiple airlines fly between 2 same airports</mark>
-<mark style="background: #BBFABBA6;"> a simple graph has no self loop or multiple edges</mark></li>
<li>for a <mark style="background: #BBFABBA6;">simple directed graph the max number of edges for n vertices</mark> <code>= n(n-1)</code></li>
<li>for a <mark style="background: #BBFABBA6;">simple undirected graph the max number of edges for n vertices</mark> <code>= n(n-1)/2</code></li>
<li><mark style="background: #BBFABBA6;">a denser graph has number of edges closer to the max limit else its sparse</mark>
<ul>
<li><mark style="background: #BBFABBA6;">for a dense graph we use adjacency matrix and for sparse we use adjacency list</mark></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">path</mark>
<ul>
<li><mark style="background: #BBFABBA6;">simple path when vertices/edges are not repeated</mark></li>
<li><mark style="background: #BBFABBA6;">if repeated it is a walk</mark>
<ul>
<li><mark style="background: #BBFABBA6;">closed walk when start and end is the same vertex</mark> <mark style="background: #BBFABBA6;">also called cycle</mark>
<ul>
<li>trees are acyclic</li>
<li>singly and doubly linked lists are acyclic but we also have <mark style="background: #BBFABBA6;">cyclic/circular linked list where the last node points to the 1st node (not the head)</mark></li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">trail when edges are not repeated but vertices are</mark></li>
<li><mark style="background: #BBFABBA6;">representing graph</mark> in memory
<ul>
<li><mark style="background: #BBFABBA6;">using 2 vectors</mark>
<ul>
<li><mark style="background: #BBFABBA6;">one stores the content of the vertex called vertex list</mark></li>
<li>and <mark style="background: #BBFABBA6;">edge list which is a vector of a struct</mark> and <mark style="background: #BBFABBA6;">stores 2 integers that indicate a link between the same indices corresponding to the vertex list</mark> <mark style="background: #BBFABBA6;">(and weight also if needed)</mark></li>
<li>we know every vertex stored in the vertex list vector has an index</li>
<li>we can imagine that an edge connects these indices instead of pointing to them</li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-25%2014-25-06.png" alt="creating a graph"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #D2B3FFA6;">Common Operations</mark>
<ul>
<li><mark style="background: #BBFABBA6;">finding adjacent nodes,</mark> <mark style="background: #BBFABBA6;">checking if 2 nodes are connected is</mark> <code>O(number of Edges or |E|)</code> which is nearly <code>O(n^2)</code> as we know the formula for max number of edges from the number of nodes</li>
<li><code>O(n)</code> is acceptable which is <code>O(number of vertices or |V|)</code> for graphs <mark style="background: #BBFABBA6;">Using Adjacency Matrix and Adjacency List</mark>
<ul>
<li><mark style="background: #BBFABBA6;">Adjacency Matrix</mark> of order <code>|V| x |V|</code>
<ul>
<li><mark style="background: #BBFABBA6;">better for dense graphs because we will store many 0s for a sparse graph</mark></li>
<li><mark style="background: #BBFABBA6;">huge storage footprint</mark></li>
<li><mark style="background: #BBFABBA6;">we have a vertex list of length equal to the total number of vertices in the graph</mark>
<ul>
<li>if the length of vertex list be p then the adjacency matrix is <code>pxp</code></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">for any element at index i of the vertex list, row i of adjacency matrix has values 0 or 1 for every column</mark>
<ul>
<li>for column number c and row number r of the adjacency matrix if the value is 1 it means that the element at index r of the vertex list is connected to the element at index c of the vertex list in the graph and 0 means it is not connected</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">for any undirected graph the adjacency matrix will be symmetric</mark> so <code>Aij == Aji</code> so we can omit upper or lower triangular matrix with diagonal of matrix as the hypotenuse</li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-25%2014-39-31.png" alt="adjacency matrix of a graph"></li>
<li><mark style="background: #BBFABBA6;">to find adjacent nodes we do a linear search on the vertex list and then do a linear search on the row of adjacency matrix</mark> corresponding to the index found in vertex list
<ul>
<li>which is <code>O(V+V) = O(2V) = O(V)</code></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">to find if 2 nodes are connected or not</mark> we can pass their indices i and j and we just need to <mark style="background: #BBFABBA6;">find the value of A[i][j] in the Adjacency matrix and see if it is 0 or 1</mark> which is <code>O(1)</code>
<ul>
<li>if the alphabets are given then we need to do a linear search to find the index in the vertex list making it <code>O(V)</code></li>
<li>this can be avoided by using hash map so it will always be <code>O(1)</code></li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">for weighted graph replace 1 with edge weight and 0 with INT_MAX</mark></li>
<li><mark style="background: #BBFABBA6;">for facebook, using adjacent matrix optimally means for 1 billion users everyone is a friend of everyone else which is impossible so lot of memory is wasted in storing who is not a friend of whom which is redundant as we can figure that out if we just knew who is a friend of who which is infact more important</mark></li>
</ul>
</li>
<li>So we use <mark style="background: #BBFABBA6;">Adjacency List</mark> which is an array of pointers
<ul>
<li>less memory as space complexity is <code>O(number of edges)</code> as <code>|E| &lt;&lt; |V|^2</code></li>
<li><img src="https://raw.githubusercontent.com/JayaswalPrateek/MyCSnotesForME/main/Attachments/Screenshot%20from%202023-01-25%2021-00-55.png" alt="Adjacency List"></li>
<li>we <mark style="background: #BBFABBA6;">need to perform linear search or binary search on the adjacency list so for finding if 2 nodes are connected</mark> <code>O(|V|)</code> or <code>O(log |V|)</code> which was <code>O(1)</code> in Adjacency Matrix</li>
<li><mark style="background: #BBFABBA6;">finding adjacent nodes(all the neighbors of a node) is O(v) same as Adjacency Matrix</mark></li>
<li><mark style="background: #BBFABBA6;">Adjacency Matrix used when the graphs is dense</mark> and |V| and |E| are small otherwise Adjacency List is practically preferred over Adjacency Matrix most of the time</li>
</ul>
</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">adding a new edge</mark>
<ul>
<li><mark style="background: #BBFABBA6;">for adjacency matrix flip a zero to one</mark></li>
<li><mark style="background: #BBFABBA6;">for a list if we are using array of pointers we need to create a new array and copy previous elements into it and then add the new one</mark>
<ul>
<li>so <mark style="background: #BBFABBA6;">use linked list instead? yes</mark> and each pointer in the array points to the head of a linked list and the node will store weight if the graph is weighted</li>
<li><mark style="background: #BBFABBA6;">Adjacency List always uses Linked List and not array or vector</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</body>
</html>
